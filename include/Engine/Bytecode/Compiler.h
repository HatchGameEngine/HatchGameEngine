#ifndef ENGINE_BYTECODE_COMPILER_H
#define ENGINE_BYTECODE_COMPILER_H

#include <Engine/Bytecode/CompilerEnums.h>
#include <Engine/Bytecode/Types.h>

class Compiler {
private:
	void WarnVariablesUnusedUnset();
	void WriteBytecode(Stream* stream, const char* filename);

public:
	static Parser parser;
	static Scanner scanner;
	static ParseRule* Rules;
	static vector<ObjFunction*> Functions;
	static vector<Local> ModuleLocals;
	static vector<Local> ModuleConstants;
	static HashMap<VMValue>* StandardConstants;
	static HashMap<Token>* TokenMap;
	static bool DoLogging;
	static bool ShowWarnings;
	static bool WriteDebugInfo;
	static bool WriteSourceFilename;
	static bool DoOptimizations;
	Compiler* Enclosing = nullptr;
	ObjFunction* Function = nullptr;
	int Type = 0;
	string ClassName;
	Local Locals[0x100];
	vector<Local> Constants;
	int LocalCount = 0;
	int ScopeDepth = 0;
	vector<Uint32> ClassHashList;
	vector<Uint32> ClassExtendedList;
	vector<Local>* UnusedVariables = nullptr;
	vector<Local>* UnsetVariables = nullptr;

	Token MakeToken(int type);
	Token MakeTokenRaw(int type, const char* message);
	Token ErrorToken(const char* message);
	bool IsEOF();
	bool IsDigit(char c);
	bool IsHexDigit(char c);
	bool IsAlpha(char c);
	bool IsIdentifierStart(char c);
	bool IsIdentifierBody(char c);
	bool MatchChar(char expected);
	char AdvanceChar();
	char PrevChar();
	char PeekChar();
	char PeekNextChar();
	virtual void SkipWhitespace();
	int CheckKeyword(int start, int length, const char* rest, int type);
	virtual int GetKeywordType();
	Token StringToken();
	Token NumberToken();
	Token IdentifierToken();
	virtual Token ScanToken();
	void AdvanceToken();
	Token NextToken();
	Token PeekToken();
	Token PeekNextToken();
	Token PrevToken();
	bool MatchToken(int expectedType);
	bool MatchAssignmentToken();
	bool CheckToken(int expectedType);
	void ConsumeToken(int type, const char* message);
	void SynchronizeToken();
	bool ReportError(int line, int pos, bool fatal, const char* string, ...);
	void ErrorAt(Token* token, const char* message, bool fatal);
	void Error(const char* message);
	void ErrorAtCurrent(const char* message);
	void Warning(const char* message);
	void WarningInFunction(const char* format, ...);
	int ParseVariable(const char* errorMessage, bool constant);
	bool IdentifiersEqual(Token* a, Token* b);
	void MarkInitialized();
	void DefineVariableToken(Token global, bool constant);
	int DeclareVariable(Token* name, bool constant);
	int ParseModuleVariable(const char* errorMessage, bool constant);
	void DefineModuleVariable(int local);
	int DeclareModuleVariable(Token* name, bool constant);
	void EmitSetOperation(Uint8 setOp, int arg, Token name);
	void EmitGetOperation(Uint8 getOp, int arg, Token name);
	void EmitAssignmentToken(Token assignmentToken);
	void EmitCopy(Uint8 count);
	void EmitCall(const char* name, int argCount, bool isSuper);
	void EmitCall(Token name, int argCount, bool isSuper);
	void NamedVariable(Token name, bool canAssign);
	void ScopeBegin();
	void ScopeEnd();
	void ClearToScope(int depth);
	void PopToScope(int depth);
	void PopMultiple(int count);
	int AddLocal(Token name);
	int AddLocal(const char* name, size_t len);
	int AddHiddenLocal(const char* name, size_t len);
	void RenameLocal(Local* local, const char* name, size_t len);
	void RenameLocal(Local* local, const char* name);
	void RenameLocal(Local* local, Token name);
	int ResolveLocal(Token* name, Local* result = NULL);
	int AddModuleLocal(Token name);
	int ResolveModuleLocal(Token* name, Local* result = NULL);
	Uint8 GetArgumentList();
	void GetThis(bool canAssign);
	void GetSuper(bool canAssign);
	void GetDot(bool canAssign);
	void GetElement(bool canAssign);
	void GetGrouping(bool canAssign);
	void GetLiteral(bool canAssign);
	void GetInteger(bool canAssign);
	void GetDecimal(bool canAssign);
	ObjString* MakeString(Token token);
	void GetString(bool canAssign);
	void GetArray(bool canAssign);
	void GetMap(bool canAssign);
	bool IsConstant();
	void GetConstant(bool canAssign);
	int GetConstantValue();
	void GetVariable(bool canAssign);
	void GetLogicalAND(bool canAssign);
	void GetLogicalOR(bool canAssign);
	void GetConditional(bool canAssign);
	void GetUnary(bool canAssign);
	void GetNew(bool canAssign);
	void GetBinary(bool canAssign);
	void GetHas(bool canAssign);
	void GetSuffix(bool canAssign);
	void GetCall(bool canAssign);
	void GetExpression();
	void GetPrintStatement();
	void GetExpressionStatement();
	void GetContinueStatement();
	void GetDoWhileStatement();
	void GetReturnStatement();
	void GetRepeatStatement();
	void GetSwitchStatement();
	void GetCaseStatement();
	void GetDefaultStatement();
	void GetWhileStatement();
	void GetBreakStatement();
	void GetBlockStatement();
	void GetWithStatement();
	void GetForStatement();
	void GetForEachStatement();
	void GetIfStatement();
	void GetStatement();
	int GetFunction(int type, string className);
	int GetFunction(int type);
	void GetMethod(Token className);
	void GetVariableDeclaration(bool constant);
	void GetModuleVariableDeclaration();
	void GetPropertyDeclaration(Token propertyName);
	void GetClassDeclaration();
	void GetEnumDeclaration();
	void GetImportDeclaration();
	void GetUsingDeclaration();
	void GetEventDeclaration();
	void GetDeclaration();
	static void MakeRules();
	ParseRule* GetRule(int type);
	void ParsePrecedence(Precedence precedence);
	Uint32 GetHash(char* string);
	Uint32 GetHash(Token token);
	Chunk* CurrentChunk();
	int CodePointer();
	void EmitByte(Uint8 byte);
	void EmitBytes(Uint8 byte1, Uint8 byte2);
	void EmitUint16(Uint16 value);
	void EmitUint32(Uint32 value);
	void EmitSint32(Sint32 value);
	void EmitFloat(float value);
	int GetConstantIndex(VMValue value);
	int EmitConstant(VMValue value);
	static bool
	GetEmittedConstant(Chunk* chunk, Uint8* code, VMValue* value = NULL, int* index = NULL);
	void EmitLoop(int loopStart);
	int GetJump(int offset);
	int GetPosition();
	int EmitJump(Uint8 instruction);
	int EmitJump(Uint8 instruction, int jump);
	void PatchJump(int offset, int jump);
	void PatchJump(int offset);
	void EmitStringHash(const char* string);
	void EmitStringHash(Token token);
	void EmitReturn();
	void StartBreakJumpList();
	void EndBreakJumpList();
	void StartContinueJumpList();
	void EndContinueJumpList();
	void StartSwitchJumpList();
	void EndSwitchJumpList();
	int FindConstant(VMValue value);
	int MakeConstant(VMValue value);
	bool HasThis();
	void SetReceiverName(const char* name);
	void SetReceiverName(Token name);
	int CheckInfixOptimize(int preCount, int preConstant, ParseFn fn);
	int CheckPrefixOptimize(int preCount, int preConstant, ParseFn fn);
	static int GetTotalOpcodeSize(uint8_t* op);
	static int HashInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int ConstantInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int SimpleInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int ByteInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int ShortInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int LocalInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int MethodInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int InvokeInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int JumpInstruction(uint8_t opcode, int sign, Chunk* chunk, int offset);
	static int ClassInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int EnumInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int WithInstruction(uint8_t opcode, Chunk* chunk, int offset);
	static int DebugInstruction(Chunk* chunk, int offset);
	static void DebugChunk(Chunk* chunk, const char* name, int minArity, int maxArity);
	static void Init();
	static void GetStandardConstants();
	static void PrepareCompiling();
	void Initialize(Compiler* enclosing, int scope, int type);
	bool Compile(const char* filename, const char* source, Stream* output);
	void Finish();
	virtual ~Compiler();
	static void FinishCompiling();
	static void Dispose();
};

#endif /* ENGINE_BYTECODE_COMPILER_H */
