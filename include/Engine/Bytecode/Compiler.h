#ifndef ENGINE_BYTECODE_COMPILER_H
#define ENGINE_BYTECODE_COMPILER_H

#include <Engine/Bytecode/Types.h>
#include <Engine/Bytecode/CompilerEnums.h>

class Compiler {
private:
    void WarnVariablesUnused();
    void WriteBytecode(Stream* stream, const char* filename);

public:
    static Parser               parser;
    static Scanner              scanner;
    static ParseRule*           Rules;
    static vector<ObjFunction*> Functions;
    static vector<Local>        ModuleLocals;
    static HashMap<Token>*      TokenMap;
    static bool                 ShowWarnings;
    static bool                 WriteDebugInfo;
    static bool                 WriteSourceFilename;
    Compiler* Enclosing = nullptr;
    ObjFunction* Function = nullptr;
    int Type = 0;
    string ClassName;
    Local Locals[0x100];
    int LocalCount = 0;
    int ScopeDepth = 0;
    vector<Uint32> ClassHashList;
    vector<Uint32> ClassExtendedList;
    vector<Local>* UnusedVariables = nullptr;

    Token MakeToken(int type);
    Token MakeTokenRaw(int type, const char* message);
    Token ErrorToken(const char* message);
    bool IsEOF();
    bool IsDigit(char c);
    bool IsHexDigit(char c);
    bool IsAlpha(char c);
    bool IsIdentifierStart(char c);
    bool IsIdentifierBody(char c);
    bool MatchChar(char expected);
    char AdvanceChar();
    char PrevChar();
    char PeekChar();
    char PeekNextChar();
    virtual void SkipWhitespace();
    int CheckKeyword(int start, int length, const char* rest, int type);
    virtual int GetKeywordType();
    Token StringToken();
    Token NumberToken();
    Token IdentifierToken();
    virtual Token ScanToken();
    void AdvanceToken();
    Token NextToken();
    Token PeekToken();
    Token PeekNextToken();
    Token PrevToken();
    bool MatchToken(int expectedType);
    bool MatchAssignmentToken();
    bool CheckToken(int expectedType);
    void ConsumeToken(int type, const char* message);
    void SynchronizeToken();
    bool ReportError(int line, int pos, bool fatal, const char* string, ...);
    void ErrorAt(Token* token, const char* message, bool fatal);
    void Error(const char* message);
    void ErrorAtCurrent(const char* message);
    void Warning(const char* message);
    void WarningInFunction(const char* format, ...);
    void ParseVariable(const char* errorMessage);
    bool IdentifiersEqual(Token* a, Token* b);
    void MarkInitialized();
    void DefineVariableToken(Token global);
    void DeclareVariable(Token* name);
    int ParseModuleVariable(const char* errorMessage);
    void DefineModuleVariable(int local);
    int DeclareModuleVariable(Token* name);
    void EmitSetOperation(Uint8 setOp, int arg, Token name);
    void EmitGetOperation(Uint8 getOp, int arg, Token name);
    void EmitAssignmentToken(Token assignmentToken);
    void EmitCopy(Uint8 count);
    void EmitCall(const char *name, int argCount, bool isSuper);
    void EmitCall(Token name, int argCount, bool isSuper);
    void NamedVariable(Token name, bool canAssign);
    void ScopeBegin();
    void ScopeEnd();
    void ClearToScope(int depth);
    void PopToScope(int depth);
    void PopMultiple(int count);
    int AddLocal(Token name);
    int AddLocal(const char* name, size_t len);
    int AddHiddenLocal(const char* name, size_t len);
    void RenameLocal(Local* local, const char* name, size_t len);
    void RenameLocal(Local* local, const char* name);
    void RenameLocal(Local* local, Token name);
    int ResolveLocal(Token* name);
    int AddModuleLocal(Token name);
    int ResolveModuleLocal(Token* name);
    Uint8 GetArgumentList();
    void GetThis(bool canAssign);
    void GetSuper(bool canAssign);
    void GetDot(bool canAssign);
    void GetElement(bool canAssign);
    void GetGrouping(bool canAssign);
    void GetLiteral(bool canAssign);
    void GetInteger(bool canAssign);
    void GetDecimal(bool canAssign);
    ObjString* MakeString(Token token);
    void GetString(bool canAssign);
    void GetArray(bool canAssign);
    void GetMap(bool canAssign);
    bool IsConstant();
    void GetConstant(bool canAssign);
    int GetConstantValue();
    void GetVariable(bool canAssign);
    void GetLogicalAND(bool canAssign);
    void GetLogicalOR(bool canAssign);
    void GetConditional(bool canAssign);
    void GetUnary(bool canAssign);
    void GetNew(bool canAssign);
    void GetBinary(bool canAssign);
    void GetHas(bool canAssign);
    void GetSuffix(bool canAssign);
    void GetCall(bool canAssign);
    void GetExpression();
    void GetPrintStatement();
    void GetExpressionStatement();
    void GetContinueStatement();
    void GetDoWhileStatement();
    void GetReturnStatement();
    void GetRepeatStatement();
    void GetSwitchStatement();
    void GetCaseStatement();
    void GetDefaultStatement();
    void GetWhileStatement();
    void GetBreakStatement();
    void GetBlockStatement();
    void GetWithStatement();
    void GetForStatement();
    void GetForEachStatement();
    void GetIfStatement();
    void GetStatement();
    int GetFunction(int type, string className);
    int GetFunction(int type);
    void GetMethod(Token className);
    void GetVariableDeclaration();
    void GetModuleVariableDeclaration();
    void GetPropertyDeclaration(Token propertyName);
    void GetClassDeclaration();
    void GetEnumDeclaration();
    void GetImportDeclaration();
    void GetUsingDeclaration();
    void GetEventDeclaration();
    void GetDeclaration();
    static void MakeRules();
    ParseRule* GetRule(int type);
    void ParsePrecedence(Precedence precedence);
    Uint32 GetHash(char* string);
    Uint32 GetHash(Token token);
    Chunk* CurrentChunk();
    int CodePointer();
    void EmitByte(Uint8 byte);
    void EmitBytes(Uint8 byte1, Uint8 byte2);
    void EmitUint16(Uint16 value);
    void EmitUint32(Uint32 value);
    int GetConstantIndex(VMValue value);
    int EmitConstant(VMValue value);
    void EmitLoop(int loopStart);
    int GetJump(int offset);
    int GetPosition();
    int EmitJump(Uint8 instruction);
    int EmitJump(Uint8 instruction, int jump);
    void PatchJump(int offset, int jump);
    void PatchJump(int offset);
    void EmitStringHash(const char* string);
    void EmitStringHash(Token token);
    void EmitReturn();
    void StartBreakJumpList();
    void EndBreakJumpList();
    void StartContinueJumpList();
    void EndContinueJumpList();
    void StartSwitchJumpList();
    void EndSwitchJumpList();
    int FindConstant(VMValue value);
    int MakeConstant(VMValue value);
    bool HasThis();
    void SetReceiverName(const char *name);
    void SetReceiverName(Token name);
    static int HashInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int ConstantInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int SimpleInstruction(uint8_t opcode, int offset);
    static int ByteInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int ShortInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int LocalInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int MethodInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int InvokeInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int JumpInstruction(uint8_t opcode, int sign, Chunk* chunk, int offset);
    static int ClassInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int EnumInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int WithInstruction(uint8_t opcode, Chunk* chunk, int offset);
    static int DebugInstruction(Chunk* chunk, int offset);
    static void DebugChunk(Chunk* chunk, const char* name, int minArity, int maxArity);
    static void Init();
    static void PrepareCompiling();
    void Initialize(Compiler* enclosing, int scope, int type);
    bool Compile(const char* filename, const char* source, const char* output);
    void Finish();
    virtual ~Compiler();
    static void FinishCompiling();
    static void Dispose();
};

#endif /* ENGINE_BYTECODE_COMPILER_H */
