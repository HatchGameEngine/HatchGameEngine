#!/usr/bin/env python3

BYTES_PER_LINE = 12
INDENT_SIZE = 2

def read_file(infile_path, outfile_path):
  import os
  import pathlib
  import re

  with open(infile_path, 'rb') as infile, open(outfile_path, 'w') as outfile:
    in_filename = pathlib.Path(infile_path).name
    out_filename = pathlib.Path(outfile_path).name

    outfile.write(f"// This file was generated by running the following command:\n")
    outfile.write(f"// tools/bin2c.py {in_filename} {out_filename}\n\n")

    infile.seek(0, os.SEEK_END)
    infile_size = infile.tell()
    infile.seek(0, 0)

    array_name = re.sub(r'[^a-zA-Z0-9]', '_', in_filename)
    outfile.write("unsigned char ")
    outfile.write(array_name)
    outfile.write("[] = {\n")

    bytes_left = infile_size

    while True:
      chunk = infile.read(BYTES_PER_LINE)
      if not chunk:
        break

      line = ' ' * INDENT_SIZE
      line += ', '.join(f'0x{byte:02x}' for byte in chunk)

      outfile.write(line)

      bytes_left -= BYTES_PER_LINE
      if bytes_left > 0:
        outfile.write(',')

      outfile.write('\n')

    outfile.write("};\n")
    outfile.write(f"unsigned int {array_name}_len = {infile_size};\n")

  return 0

def main(argv, argc):
  if argc < 3:
    print("usage: bin2c <input> <output>")
    return 1

  return read_file(argv[1], argv[2])

if __name__ == '__main__':
  from sys import argv, exit

  exit_code = main(argv, len(argv))

  exit(exit_code)
